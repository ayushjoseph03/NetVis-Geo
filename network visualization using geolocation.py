# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16RMyBEWRV-2nPCpKfbMN7QO7jqZH0SaI
"""

import dpkt
import socket
import pygeoip
import os
from pathlib import Path

# ======================
# 1. CONFIGURATION
# ======================
YOUR_PCAP_FILE = "/abc.pcap"  # ← CHANGE THIS to your PCAP path
OUTPUT_KML = "network_vis.kml"

# ======================
# 2. GEOIP SETUP
# ======================
def setup_geoip():
    """Downloads GeoIP database if missing"""
    GEOIP_PATH = "GeoLiteCity.dat"
    if not os.path.exists(GEOIP_PATH):
        print("Downloading GeoIP database...")
        try:
            import gzip
            import urllib.request
            url = "https://web.archive.org/web/20230116065339/https://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz"
            urllib.request.urlretrieve(url, "temp.dat.gz")
            with gzip.open('temp.dat.gz', 'rb') as f_in:
                with open(GEOIP_PATH, 'wb') as f_out:
                    f_out.write(f_in.read())
            os.remove('temp.dat.gz')
            print("GeoIP database installed")
        except Exception as e:
            print(f"Failed to download GeoIP: {e}")
            return None
    return GEOIP_PATH

# ======================
# 3. PCAP PROCESSING
# ======================
def process_pcap(pcap_path, geoip_path):
    """Converts PCAP to KML placemarks"""
    gi = pygeoip.GeoIP(geoip_path)
    placemarks = []
    stats = {
        'total': 0,
        'ip': 0,
        'geo': 0,
        'private_ips': 0,
        'errors': 0
    }

    def is_private(ip):
        """Check if IP is private (non-routable)"""
        priv_ranges = [
            ('10.0.0.0', '10.255.255.255'),
            ('172.16.0.0', '172.31.255.255'),
            ('192.168.0.0', '192.168.255.255')
        ]
        ip_num = struct.unpack('!I', socket.inet_aton(ip))[0]
        for start, end in priv_ranges:
            start_num = struct.unpack('!I', socket.inet_aton(start))[0]
            end_num = struct.unpack('!I', socket.inet_aton(end))[0]
            if start_num <= ip_num <= end_num:
                return True
        return False

    with open(pcap_path, 'rb') as f:
        try:
            pcap = dpkt.pcap.Reader(f)
        except:
            print("ERROR: Invalid PCAP file format")
            return None, stats

        for ts, buf in pcap:
            stats['total'] += 1
            try:
                eth = dpkt.ethernet.Ethernet(buf)
                if not isinstance(eth.data, dpkt.ip.IP):
                    continue

                ip = eth.data
                src = socket.inet_ntoa(ip.src)
                dst = socket.inet_ntoa(ip.dst)

                # Skip private IPs
                if is_private(src) or is_private(dst):
                    stats['private_ips'] += 1
                    continue

                stats['ip'] += 1
                src_geo = gi.record_by_name(src)
                dst_geo = gi.record_by_name(dst)

                if not (src_geo and dst_geo):
                    continue

                stats['geo'] += 1
                placemark = f'''<Placemark>
    <name>{src} → {dst}</name>
    <description>
        Protocol: {'TCP' if isinstance(ip.data, dpkt.tcp.TCP) else
                 'UDP' if isinstance(ip.data, dpkt.udp.UDP) else 'Other'}
        Source: {src_geo.get('city','Unknown')}, {src_geo.get('country_name','Unknown')}
        Destination: {dst_geo.get('city','Unknown')}, {dst_geo.get('country_name','Unknown')}
    </description>
    <styleUrl>#trafficLine</styleUrl>
    <LineString>
        <altitudeMode>absolute</altitudeMode>
        <coordinates>
            {src_geo['longitude']},{src_geo['latitude']},50000
            {dst_geo['longitude']},{dst_geo['latitude']},50000
        </coordinates>
    </LineString>
</Placemark>'''
                placemarks.append(placemark)

            except Exception as e:
                stats['errors'] += 1
                continue

    return placemarks, stats

# ======================
# 4. KML GENERATION
# ======================
def generate_kml(placemarks, output_path):
    """Generates the final KML file"""
    kml_template = '''<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
    <name>Network Traffic</name>
    <Style id="trafficLine">
        <LineStyle>
            <color>ff00aaff</color>
            <width>2.5</width>
        </LineStyle>
    </Style>
    {placemarks}
</Document>
</kml>'''

    with open(output_path, 'w') as f:
        f.write(kml_template.format(placemarks='\n'.join(placemarks)))

# ======================
# 5. MAIN EXECUTION
# ======================
if __name__ == '__main__':
    import struct  # Needed for IP checks

    # Verify PCAP exists
    if not os.path.exists(YOUR_PCAP_FILE):
        print(f"ERROR: PCAP file not found at {YOUR_PCAP_FILE}")
        print("Please set YOUR_PCAP_FILE to your capture file path")
        exit(1)

    # Setup GeoIP
    geoip_path = setup_geoip()
    if not geoip_path:
        exit(1)

    # Process PCAP
    print(f"\nProcessing {YOUR_PCAP_FILE}...")
    placemarks, stats = process_pcap(YOUR_PCAP_FILE, geoip_path)

    if not placemarks:
        print("\nERROR: No valid connections found")
        print("Possible reasons:")
        print(f"- Your PCAP contains only private IPs ({stats['private_ips']} found)")
        print(f"- GeoIP couldn't locate the public IPs ({stats['ip']} public IPs processed)")
        print(f"- File may not contain IP traffic ({stats['total']} total packets)")
        exit(1)

    # Generate KML
    generate_kml(placemarks, OUTPUT_KML)

    # Print results
    print(f"\nSuccessfully processed {stats['total']} packets:")
    print(f"- {stats['ip']} public IP packets")
    print(f"- {stats['geo']} geolocated connections")
    print(f"- {stats['errors']} errors skipped")
    print(f"\nGenerated {OUTPUT_KML} with {len(placemarks)} placemarks")

    print("\nVisualization instructions:")
    print("1. Open Google Earth Pro")
    print("2. Go to File → Open")
    print(f"3. Select {OUTPUT_KML}")
    print("4. Zoom out to see global connections")

